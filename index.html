<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>–¢–≤–æ–π –≥–æ–¥ ‚Äî –ª–∏—Å—Ç–∞–ª–∫–∞</title>
  <link rel="stylesheet" href="styles.css">
</head>
<body>

<div class="app">
  <!-- Story-style progress -->
  <div class="progress" id="progress" aria-hidden="true"></div>

  <div class="track" id="track"></div>

  <div class="hint">–ü—Ä–æ—Å—Ç–æ –ª–∏—Å—Ç–∞–π –≤–ø—Ä–∞–≤–æ</div>
  <div class="dots" id="dots"></div>

  <div class="controls">
    <button class="btn" id="prev">‚Üê</button>
    <button class="btn" id="next">‚Üí</button>
  </div>
</div>

<script>
const slides = [
  {pill:"Wrapped 2025",title:"–ò—Ç–æ–≥–∏ –¥–ª—è —Ç–µ–±—è",big:"2025",desc:"–ù–µ–º–Ω–æ–≥–æ —Ü–∏—Ñ—Ä –∏ –Ω–µ–º–Ω–æ–≥–æ —é–º–æ—Ä–∞."},
  {pill:"Wrapped 2025",title:"–ë—ç–º–±–∏ —Ç—è–≤–∫–Ω—É–ª–∞",big:"‚âà 5",desc:"–ù–æ –æ–Ω–∞ –≤—Å–µ —Ä–∞–≤–Ω–æ —Ç–µ–±—è –ª—é–±–∏—Ç –±–æ–ª—å—à–µ –≤—Å–µ—Ö."},
  {pill:"Wrapped 2025",title:"–°–ª–æ–≤–æ ¬´–∫–∞–∫–∞—Ç—å¬ª",big:"32",desc:"–ö–∞–∫–∞–ª–∏ –º—ã –ø–æ-—Ä–∞–∑–Ω–æ–º—É."},
  {pill:"Wrapped 2025",title:"¬´–ß—Ç–æ –Ω–∞ —É–∂–∏–Ω?¬ª",big:"30",desc:"–ì–ª–∞–≤–Ω—ã–π –≤–æ–ø—Ä–æ—Å –≥–æ–¥–∞."},
  {pill:"Wrapped 2025",title:"¬´–Ø –≤—ã—à–µ–ª¬ª",big:"29 —Ä–∞–∑",desc:"–°—Ä–µ–¥–Ω–µ–µ –∑–Ω–∞—á–µ–Ω–∏–µ."},
  {pill:"Wrapped 2025",title:"¬´–ß–º–æ–∫¬ª",big:"398",desc:"–ü–æ—á—Ç–∏ 400 ‚Äî –Ω–æ —Ö–æ—Ç–µ–ª–æ—Å—å –±—ã –±–æ–ª—å—à–µ. —Ö3"},
  {pill:"Wrapped 2025",title:"–ü–æ–±—ã–≤–∞–ª–∏ –≤ –Ω–æ–≤—ã—Ö –º–µ—Å—Ç–∞—Ö",big:"2 —Ä–∞–∑–∞",desc:"–ú–æ—Å–∫–≤–∞ –∏ –°–∞–Ω–∫—Ç-–ü–µ—Ç–µ—Ä–±—É—Ä–≥."},
  {pill:"Wrapped 2025",title:"–ü—Ä–æ–≤–µ–ª–∏ –≤–º–µ—Å—Ç–µ",big:"7 200 –º–∏–Ω.",desc:"–ò –¥–∞–∂–µ –Ω–µ —Ä—É–≥–∞–ª–∏—Å—å!"},
  {pill:"Wrapped 2025",title:"–°–∞–º—ã–π —Å–ø–æ–∫–æ–π–Ω—ã–π –º–æ–º–µ–Ω—Ç",big:"–°–æ–Ω",desc:"–ö–æ–≥–¥–∞ –º—ã –≤–º–µ—Å—Ç–µ –∏ —è –¥–æ—Å—Ç–∞—é —Ç–µ–±—è –Ω–æ–∂–∫–æ–π."},
  {pill:"Wrapped 2025",title:"–õ—É—á—à–µ–µ –∑–∞ –≥–æ–¥",big:"–¢—ã",desc:"–ü—É—Å—Ç—å 2026 –±—É–¥–µ—Ç –µ—â—ë –ª—É—á—à–µ. –Ø ‚ù§Ô∏è —Ç–µ–±—è!"}
];

const track = document.getElementById("track");
const dots = document.getElementById("dots");
const progress = document.getElementById("progress");

let index = 0;

/** ===== Render slides ===== */
slides.forEach((s, i) => {
  const slide = document.createElement("section");
  slide.className = "slide";
  slide.style.setProperty("--gx", `${20 + (i * 7) % 60}%`);
  slide.style.setProperty("--gy", `${30 + (i * 9) % 50}%`);

  slide.innerHTML = `
    <div class="card">
      <div class="card-inner">
        <div class="meta">
          <div class="pill">üéâ ${s.pill}</div>
          <div>${i + 1}/${slides.length}</div>
        </div>
        <h1 class="title">${s.title}</h1>
        <div class="big">${s.big}</div>
        <p class="desc">${s.desc}</p>
      </div>
    </div>
  `;
  track.appendChild(slide);

  const dot = document.createElement("div");
  dot.className = "dot";
  dot.onclick = () => go(i, { animate: true });
  dots.appendChild(dot);
});

/** ===== Story progress segments ===== */
const segs = [];
slides.forEach((_, i) => {
  const seg = document.createElement("div");
  seg.className = "seg";
  seg.innerHTML = `<div class="fill"></div>`;
  seg.onclick = () => go(i, { animate: true });
  progress.appendChild(seg);
  segs.push(seg);
});

function setActiveUI(dirClass){
  document.querySelectorAll(".slide").forEach((s, j) => {
    s.classList.remove("active", "from-right", "from-left");
    if (j === index){
      s.classList.add("active", dirClass);
    }
  });

  document.querySelectorAll(".dot").forEach((d, j) =>
    d.classList.toggle("active", j === index)
  );

  // progress fills (past=100%, current=100% unless dragging, future=0)
  segs.forEach((seg, j) => {
    const fill = seg.querySelector(".fill");
    if (j < index) fill.style.transform = "scaleX(1)";
    else if (j > index) fill.style.transform = "scaleX(0)";
    else fill.style.transform = "scaleX(1)";
  });
}

function setTrackPx(px, { animate } = { animate: true }){
  track.classList.toggle("no-anim", !animate);
  track.style.transform = `translate3d(${px}px,0,0)`;
}

function slideWidth(){
  return track.getBoundingClientRect().width; // equals viewport width
}

function baseXForIndex(i){
  return -i * slideWidth();
}

/**
 * Update story progress during drag
 * dragX is px offset from base position (negative means dragging to next)
 */
function setProgressDuringDrag(dragX){
  const w = slideWidth();
  if (!w) return;

  // fraction: -1..1 (clamp)
  const f = Math.max(-1, Math.min(1, dragX / w));

  // When dragging left (f < 0): moving towards next slide (index+1)
  // current segment should "empty" a bit; next should "fill" a bit
  const cur = segs[index]?.querySelector(".fill");
  const next = segs[index + 1]?.querySelector(".fill");
  const prev = segs[index - 1]?.querySelector(".fill");

  // reset all to their base state first
  segs.forEach((seg, j) => {
    const fill = seg.querySelector(".fill");
    if (j < index) fill.style.transform = "scaleX(1)";
    else if (j > index) fill.style.transform = "scaleX(0)";
    else fill.style.transform = "scaleX(1)";
  });

  if (f < 0 && next){
    const t = Math.min(1, Math.max(0, -f)); // 0..1
    cur.style.transform = `scaleX(${1 - t})`;
    next.style.transform = `scaleX(${t})`;
  } else if (f > 0 && prev){
    const t = Math.min(1, Math.max(0, f)); // 0..1
    // dragging right towards prev: prev fills, current empties
    prev.style.transform = `scaleX(${1})`; // prev already full
    cur.style.transform = `scaleX(${1 - t})`;
  }
}

function go(i, { animate = true } = {}){
  const prevIndex = index;
  index = Math.max(0, Math.min(slides.length - 1, i));
  const dir = index > prevIndex ? "from-right" : "from-left";

  setTrackPx(baseXForIndex(index), { animate });
  setActiveUI(dir);
}

/** ===== Controls ===== */
document.getElementById("next").onclick = () => go(index + 1, { animate: true });
document.getElementById("prev").onclick = () => go(index - 1, { animate: true });

window.addEventListener("keydown", e => {
  if (e.key === "ArrowRight") go(index + 1, { animate: true });
  if (e.key === "ArrowLeft") go(index - 1, { animate: true });
});

/** ===== Inertial swipe (drag + velocity + snap) ===== */
let isDragging = false;
let startX = 0;
let startBase = 0;
let lastX = 0;
let lastT = 0;
let vx = 0; // px/ms
let activePointerId = null;

function clampX(x){
  // rubber band at edges
  const min = baseXForIndex(slides.length - 1);
  const max = baseXForIndex(0);
  if (x < min) return min + (x - min) * 0.25;
  if (x > max) return max + (x - max) * 0.25;
  return x;
}

function onDown(clientX, pointerId){
  if (activePointerId !== null) return;
  activePointerId = pointerId ?? "touch";
  isDragging = true;

  startX = clientX;
  startBase = baseXForIndex(index);

  lastX = clientX;
  lastT = performance.now();
  vx = 0;

  // turn off animation for direct follow
  track.classList.add("grabbing");
  track.classList.add("no-anim");
}

function onMove(clientX){
  if (!isDragging) return;

  const now = performance.now();
  const dx = clientX - startX;
  const target = clampX(startBase + dx);

  setTrackPx(target, { animate: false });
  setProgressDuringDrag(dx);

  // velocity
  const dt = now - lastT;
  if (dt > 0){
    const v = (clientX - lastX) / dt;
    // smooth a bit
    vx = vx * 0.75 + v * 0.25;
    lastX = clientX;
    lastT = now;
  }
}

function onUp(clientX){
  if (!isDragging) return;

  isDragging = false;
  track.classList.remove("grabbing");

  const w = slideWidth();
  const dx = clientX - startX;

  // Decision:
  // - if fast enough: use velocity
  // - else use distance threshold
  const velocityThreshold = 0.6; // px/ms
  const distanceThreshold = w * 0.18;

  let targetIndex = index;

  if (Math.abs(vx) > velocityThreshold){
    // swipe right -> previous
    targetIndex = vx > 0 ? index - 1 : index + 1;
  } else if (Math.abs(dx) > distanceThreshold){
    targetIndex = dx > 0 ? index - 1 : index + 1;
  }

  targetIndex = Math.max(0, Math.min(slides.length - 1, targetIndex));

  // restore animation
  track.classList.remove("no-anim");
  go(targetIndex, { animate: true });

  activePointerId = null;
}

/** Pointer events (best) */
window.addEventListener("pointerdown", (e) => {
  // only primary buttons/touch
  if (e.pointerType === "mouse" && e.button !== 0) return;
  onDown(e.clientX, e.pointerId);
}, { passive: true });

window.addEventListener("pointermove", (e) => {
  if (activePointerId !== e.pointerId) return;
  onMove(e.clientX);
}, { passive: true });

window.addEventListener("pointerup", (e) => {
  if (activePointerId !== e.pointerId) return;
  onUp(e.clientX);
}, { passive: true });

window.addEventListener("pointercancel", (e) => {
  if (activePointerId !== e.pointerId) return;
  onUp(e.clientX);
}, { passive: true });

/** Re-snap on resize */
window.addEventListener("resize", () => {
  setTrackPx(baseXForIndex(index), { animate: false });
  setActiveUI("from-right");
});

/** Init */
go(0, { animate: false });
</script>

</body>
</html>
