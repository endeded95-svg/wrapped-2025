<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Твой год — листалка</title>
  <link rel="stylesheet" href="styles.css">
</head>
<body>

<div class="app">
  <!-- Story-style progress -->
  <div class="progress" id="progress" aria-hidden="true"></div>

  <div class="track" id="track"></div>

  <div class="hint">Свайпай • Колесико • ← →</div>
  <div class="dots" id="dots"></div>

  <div class="controls">
    <button class="btn" id="prev">←</button>
    <button class="btn" id="next">→</button>
  </div>
</div>

<script>
const slides = [
  {pill:"Wrapped 2025",title:"Итоги для тебя",big:"2025",desc:"Немного цифр и немного юмора."},
  {pill:"Wrapped 2025",title:"Бэмби тявкнула",big:"≈ 5",desc:"Но она все равно тебя любит больше всех."},
  {pill:"Wrapped 2025",title:"Слово «какать»",big:"32",desc:"Какали мы по-разному."},
  {pill:"Wrapped 2025",title:"«Что на ужин?»",big:"30",desc:"Главный вопрос года."},
  {pill:"Тайминг",title:"«Я вышел»",big:"29 раз",desc:"Среднее значение."},
  {pill:"Wrapped 2025",title:"«Чмок»",big:"398",desc:"Почти 400 — но хотелось бы больше."},
  {pill:"Wrapped 2025",title:"Побывали в новых местах",big:"2 раза",desc:"Москва и Санкт-Петербург."},
  {pill:"Wrapped 2025",title:"Провели вместе",big:"7 200 мин.",desc:"И даже не ругались!"},
  {pill:"Wrapped 2025",title:"Самый спокойный момент",big:"Сон",desc:"Когда мы вместе."},
  {pill:"Wrapped 2025",title:"Лучшее за год",big:"Ты",desc:"Пусть 2026 будет ещё лучше ❤️"}
];

const track = document.getElementById("track");
const dots = document.getElementById("dots");
const progress = document.getElementById("progress");

let index = 0;

/** ===== Render slides ===== */
slides.forEach((s, i) => {
  const slide = document.createElement("section");
  slide.className = "slide";
  slide.style.setProperty("--gx", `${20 + (i * 7) % 60}%`);
  slide.style.setProperty("--gy", `${30 + (i * 9) % 50}%`);

  slide.innerHTML = `
    <div class="card">
      <div class="card-inner">
        <div class="meta">
          <div class="pill">✨ ${s.pill}</div>
          <div>${i + 1}/${slides.length}</div>
        </div>
        <h1 class="title">${s.title}</h1>
        <div class="big">${s.big}</div>
        <p class="desc">${s.desc}</p>
      </div>
    </div>
  `;
  track.appendChild(slide);

  const dot = document.createElement("div");
  dot.className = "dot";
  dot.onclick = () => go(i, { animate: true });
  dots.appendChild(dot);
});

/** ===== Story progress segments ===== */
const segs = [];
slides.forEach((_, i) => {
  const seg = document.createElement("div");
  seg.className = "seg";
  seg.innerHTML = `<div class="fill"></div>`;
  seg.onclick = () => go(i, { animate: true });
  progress.appendChild(seg);
  segs.push(seg);
});

function setActiveUI(dirClass){
  document.querySelectorAll(".slide").forEach((s, j) => {
    s.classList.remove("active", "from-right", "from-left");
    if (j === index){
      s.classList.add("active", dirClass);
    }
  });

  document.querySelectorAll(".dot").forEach((d, j) =>
    d.classList.toggle("active", j === index)
  );

  // progress fills (past=100%, current=100% unless dragging, future=0)
  segs.forEach((seg, j) => {
    const fill = seg.querySelector(".fill");
    if (j < index) fill.style.transform = "scaleX(1)";
    else if (j > index) fill.style.transform = "scaleX(0)";
    else fill.style.transform = "scaleX(1)";
  });
}

function setTrackPx(px, { animate } = { animate: true }){
  track.classList.toggle("no-anim", !animate);
  track.style.transform = `translate3d(${px}px,0,0)`;
}

function slideWidth(){
  return track.getBoundingClientRect().width; // equals viewport width
}

function baseXForIndex(i){
  return -i * slideWidth();
}

/**
 * Update story progress during drag
 * dragX is px offset from base position (negative means dragging to next)
 */
function setProgressDuringDrag(dragX){
  const w = slideWidth();
  if (!w) return;

  // fraction: -1..1 (clamp)
  const f = Math.max(-1, Math.min(1, dragX / w));

  // When dragging left (f < 0): moving towards next slide (index+1)
  // current segment should "empty" a bit; next should "fill" a bit
  const cur = segs[index]?.querySelector(".fill");
  const next = segs[index + 1]?.querySelector(".fill");
  const prev = segs[index - 1]?.querySelector(".fill");

  // reset all to their base state first
  segs.forEach((seg, j) => {
    const fill = seg.querySelector(".fill");
    if (j < index) fill.style.transform = "scaleX(1)";
    else if (j > index) fill.style.transform = "scaleX(0)";
    else fill.style.transform = "scaleX(1)";
  });

  if (f < 0 && next){
    const t = Math.min(1, Math.max(0, -f)); // 0..1
    cur.style.transform = `scaleX(${1 - t})`;
    next.style.transform = `scaleX(${t})`;
  } else if (f > 0 && prev){
    const t = Math.min(1, Math.max(0, f)); // 0..1
    // dragging right towards prev: prev fills, current empties
    prev.style.transform = `scaleX(${1})`; // prev already full
    cur.style.transform = `scaleX(${1 - t})`;
  }
}

function go(i, { animate = true } = {}){
  const prevIndex = index;
  index = Math.max(0, Math.min(slides.length - 1, i));
  const dir = index > prevIndex ? "from-right" : "from-left";

  setTrackPx(baseXForIndex(index), { animate });
  setActiveUI(dir);
}

/** ===== Controls ===== */
document.getElementById("next").onclick = () => go(index + 1, { animate: true });
document.getElementById("prev").onclick = () => go(index - 1, { animate: true });

window.addEventListener("keydown", e => {
  if (e.key === "ArrowRight") go(index + 1, { animate: true });
  if (e.key === "ArrowLeft") go(index - 1, { animate: true });
});

/** ===== Inertial swipe (drag + velocity + snap) ===== */
let isDragging = false;
let startX = 0;
let startBase = 0;
let lastX = 0;
let lastT = 0;
let vx = 0; // px/ms
let activePointerId = null;

function clampX(x){
  // rubber band at edges
  const min = baseXForIndex(slides.length - 1);
  const max = baseXForIndex(0);
  if (x < min) return min + (x - min) * 0.25;
  if (x > max) return max + (x - max) * 0.25;
  return x;
}

function onDown(clientX, pointerId){
  if (activePointerId !== null) return;
  activePointerId = pointerId ?? "touch";
  isDragging = true;

  startX = clientX;
  startBase = baseXForIndex(index);

  lastX = clientX;
  lastT = performance.now();
  vx = 0;

  // turn off animation for direct follow
  track.classList.add("grabbing");
  track.classList.add("no-anim");
}

function onMove(clientX){
  if (!isDragging) return;

  const now = performance.now();
  const dx = clientX - startX;
  const target = clampX(startBase + dx);

  setTrackPx(target, { animate: false });
  setProgressDuringDrag(dx);

  // velocity
  const dt = now - lastT;
  if (dt > 0){
    const v = (clientX - lastX) / dt;
    // smooth a bit
    vx = vx * 0.75 + v * 0.25;
    lastX = clientX;
    lastT = now;
  }
}

function onUp(clientX){
  if (!isDragging) return;

  isDragging = false;
  track.classList.remove("grabbing");

  const w = slideWidth();
  const dx = clientX - startX;

  // Decision:
  // - if fast enough: use velocity
  // - else use distance threshold
  const velocityThreshold = 0.6; // px/ms
  const distanceThreshold = w * 0.18;

  let targetIndex = index;

  if (Math.abs(vx) > velocityThreshold){
    // swipe right -> previous
    targetIndex = vx > 0 ? index - 1 : index + 1;
  } else if (Math.abs(dx) > distanceThreshold){
    targetIndex = dx > 0 ? index - 1 : index + 1;
  }

  targetIndex = Math.max(0, Math.min(slides.length - 1, targetIndex));

  // restore animation
  track.classList.remove("no-anim");
  go(targetIndex, { animate: true });

  activePointerId = null;
}

/** Pointer events (best) */
window.addEventListener("pointerdown", (e) => {
  // only primary buttons/touch
  if (e.pointerType === "mouse" && e.button !== 0) return;
  onDown(e.clientX, e.pointerId);
}, { passive: true });

window.addEventListener("pointermove", (e) => {
  if (activePointerId !== e.pointerId) return;
  onMove(e.clientX);
}, { passive: true });

window.addEventListener("pointerup", (e) => {
  if (activePointerId !== e.pointerId) return;
  onUp(e.clientX);
}, { passive: true });

window.addEventListener("pointercancel", (e) => {
  if (activePointerId !== e.pointerId) return;
  onUp(e.clientX);
}, { passive: true });

/** Re-snap on resize */
window.addEventListener("resize", () => {
  setTrackPx(baseXForIndex(index), { animate: false });
  setActiveUI("from-right");
});

/** Init */
go(0, { animate: false });
</script>

</body>
</html>
